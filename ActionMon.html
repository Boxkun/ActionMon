<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>ActionMon</title>
    <script src="https://act.diemoe.net/overlays/common/common.min.js"></script>
    <script src="action_data.js"></script>
    <link rel="stylesheet" href="ActionMon.css">
</head>
<body>

    <div id="party-controls"></div>
    <div id="party-container"></div>

    <script>
        if (location.href.indexOf('OVERLAY_WS=') === -1 && !window.OverlayPluginApi) {
            window.__isBrowser = true;
            const c = document.getElementById('party-controls');
            if (c) {
                c.innerHTML = `
                    <div style="color: #d30000; font-weight: bold; text-align: left; padding: 10px;">
                        ⚠️ 未检测到 OverlayPlugin<br>
                        <span style="font-size:12px; font-weight:normal; color:#fff">
                            请在 ACT 中添加此悬浮窗。
                        </span>
                    </div>`;
                c.style.display = 'flex';
            }
        }

        // --- 配置区 ---
        // 根据 action ID 排除技能. 见action_data.js.
        const IGNORE_SKILL_IDS = new Set([
            "4",    // 坐骑
            "7",    // 攻击
        ]);
        
        // 滚动速度 (像素/秒)
        const SCROLL_SPEED = 75; 
        
        // 技能图标大小 (像素)
        const CELL_SIZE = 50;
        
        // 右侧边距
        const PADDING_RIGHT = 10;
        // --- 配置区 ---


        // const viewportWidthStr = window.getComputedStyle(document.documentElement).getPropertyValue('--viewport-width').trim();
        // const VIEWPORT_WIDTH = parseInt(viewportWidthStr) || 500; // 默认值 500px
        // 计算生成点
        // const SPAWN_X = VIEWPORT_WIDTH - CELL_SIZE - PADDING_RIGHT; 

        let currentSpawnX = window.innerWidth - 120 - CELL_SIZE - PADDING_RIGHT; 

        function updateSpawnX() {
            const allViewports = document.querySelectorAll('.cast-viewport');
            let validWidth = 0;
    
            for (const vp of allViewports) {
                if (vp.clientWidth > 0) {
                    validWidth = vp.clientWidth;
                    break;
                }
            }
            
            if (validWidth > 0) {
                currentSpawnX = validWidth - CELL_SIZE - PADDING_RIGHT;
            } else {
                // 估算
                const estimatedViewportWidth = window.innerWidth - 120;
                if (estimatedViewportWidth > 0) {
                    currentSpawnX = estimatedViewportWidth - CELL_SIZE - PADDING_RIGHT;
                }
            }
            
            // 防止算出负数
            if (currentSpawnX < 100) currentSpawnX = 100;
        }

        window.addEventListener('resize', () => {
            updateSpawnX();
        });

        // 初始化一次
        updateSpawnX();

        // --- 多成员数据结构 ---
        class PartyMember {
            constructor(id, name, job = null) {
                this.id = id;
                this.name = name;
                this.job = job;
                this.ribbon = null;
                this.activeSkills = [];
                this.castingMap = new Map();
                this.aoeDedupeMap = { currentActionId: null };
                this.visible = false;
                this.rowElement = null;
                this.buttonElement = null;
                
                this.createUI();
            }
            
            createUI() {
                const container = document.getElementById('party-container');
                
                // 创建控件行
                const row = document.createElement('div');
                row.className = 'party-member-row';
                row.id = `row-${this.id}`;
                row.style.display = 'none';
                
                // 创建名称标签
                const nameLabel = document.createElement('div');
                nameLabel.className = 'player-name-label';
                nameLabel.textContent = this.name;
                
                // 创建视口
                const viewport = document.createElement('div');
                viewport.className = 'cast-viewport';
                viewport.id = `viewport-${this.id}`;
                
                // 创建技能窗
                const ribbon = document.createElement('div');
                ribbon.id = `ribbon-${this.id}`;
                ribbon.style.position = 'absolute';
                ribbon.style.top = '0';
                ribbon.style.left = '0';
                ribbon.style.width = '100%';
                ribbon.style.height = '100%';
                ribbon.style.pointerEvents = 'none';
                
                viewport.appendChild(ribbon);
                row.appendChild(nameLabel);
                row.appendChild(viewport);
                container.appendChild(row);
                
                this.ribbon = ribbon;
                this.rowElement = row;
            }
            
            createControlButton() {
                const button = document.createElement('button');
                button.className = 'member-toggle';
                button.id = `toggle-${this.id}`;
                button.textContent = this.name;
                
                button.addEventListener('click', () => {
                    this.toggleVisibility();
                });
                
                this.buttonElement = button;
                this.updateButtonStyle();
                return button;
            }
            
            toggleVisibility() {
                this.visible = !this.visible;
                if (this.rowElement) {
                    this.rowElement.style.display = this.visible ? 'flex' : 'none';
                }
                this.updateButtonStyle();
            }
            
            updateButtonStyle() {
                if (!this.buttonElement) return;
                
                if (this.visible) {
                    this.buttonElement.classList.add('active');
                    this.buttonElement.classList.remove('inactive');
                } else {
                    this.buttonElement.classList.remove('active');
                    this.buttonElement.classList.add('inactive');
                }
            }
            
            updateName(newName) {
                this.name = newName;
                if (this.buttonElement) {
                    this.buttonElement.textContent = newName;
                }
                const nameLabel = document.querySelector(`#row-${this.id} .player-name-label`);
                if (nameLabel) {
                    nameLabel.textContent = newName;
                }
            }
            
            remove() {
                if (this.rowElement && this.rowElement.parentNode) {
                    this.rowElement.parentNode.removeChild(this.rowElement);
                }
                if (this.buttonElement && this.buttonElement.parentNode) {
                    this.buttonElement.parentNode.removeChild(this.buttonElement);
                }
            }
        }

        // 小队成员管理
        class PartyManager {
            constructor() {
                this.members = new Map();
                this.currentPlayerId = null;
            }
            
            getMember(memberId) {
                return this.members.get(memberId) || null;
            }
            
            createMember(memberId, memberName, job = null) {
                if (!this.members.has(memberId)) {
                    const member = new PartyMember(memberId, memberName, job);
                    this.members.set(memberId, member);
                }
                return this.members.get(memberId);
            }
            
            removeMember(memberId) {
                const member = this.members.get(memberId);
                if (member) {
                    member.remove();
                    this.members.delete(memberId);
                }
            }
            
            updatePartyControls() {
                const controlsContainer = document.getElementById('party-controls');
                controlsContainer.innerHTML = '';
                
                for (const member of this.members.values()) {
                    const button = member.createControlButton();
                    controlsContainer.appendChild(button);
                }
            }
            
            clearNonPartyMembers(partyIds) {
                const partyIdSet = new Set(partyIds);
                const membersToRemove = [];
                
                for (const memberId of this.members.keys()) {
                    if (!partyIdSet.has(memberId)) {
                        membersToRemove.push(memberId);
                    }
                }
                
                membersToRemove.forEach(memberId => this.removeMember(memberId));
            }
        }

        const partyManager = new PartyManager();

        // 更新咏唱条样式
        function updateCastBarState(skillObj, state) {
            if (!skillObj || !skillObj.castBar) return;
            
            switch (state) {
                case 'casting':
                    // 正在咏唱
                    skillObj.castBar.style.background = 'linear-gradient(90deg, rgba(100, 200, 255, 0.6), rgba(100, 150, 255, 0.0))';
                    skillObj.castBar.style.borderColor = 'rgba(150, 220, 255, 0.7)';
                    break;
                case 'interrupted':
                    // 咏唱中断
                    skillObj.castBar.style.background = 'linear-gradient(90deg, rgba(255, 100, 100, 0.8), rgba(255, 50, 50, 0.3))';
                    skillObj.castBar.style.borderColor = 'rgba(255, 100, 100, 1)';
                    break;
            }
        }

        // --- 技能事件处理 ---
        class SkillEventHandler {
            constructor() {
                this.ignoreSkillIds = IGNORE_SKILL_IDS;
            }
            
            handleLogLine(data) {
                if (data.line[0] === '21') {
                    partyManager.currentPlayerId = data.line[2]; // 获取当前玩家ID
                }

                const lineType = data.line[0]; // 日志行类型：20（开始），21（完成），22（AOE），23（中断）
                const sourceId = data.line[2]; // 技能释放者ID
                const actionId = parseInt(data.line[4], 16).toString(); //技能ID
                
                // 获取已存在的成员数据
                const member = partyManager.getMember(sourceId);
                if (!member) return; // 只处理小队成员的事件
                
                // 如果actionId变化，清空去重对象并存储新的actionId
                if (member.aoeDedupeMap.currentActionId !== actionId) {
                    member.aoeDedupeMap = { currentActionId: actionId };
                }
                
                if (typeof ACTION_DATA !== 'undefined' && (lineType === '20' || lineType === '21' || lineType === '22' || lineType === '23')) {
                    const skill = ACTION_DATA[actionId];
                    
                    if (skill) {
                        if (this.ignoreSkillIds.has(actionId)) return;
                        
                        switch (lineType) {
                            case '20':
                                this.handleCastStart(member, actionId, skill.n, skill.i, skill.c);
                                break;
                            case '21':
                                this.handleCastFinish(member, actionId, skill.n, skill.i, skill.c);
                                break;
                            case '22':
                                this.handleAoeCast(member, actionId, skill.n, skill.i, skill.c, data.line[44]);
                                break;
                            case '23':
                                this.handleCastInterrupt(member, actionId);
                                break;
                        }
                    }
                }
            }
            
            handleCastStart(member, actionId, name, iconId, skillType) {
                if (!member.visible) return;
                const skillObj = createSkillItem(member, name, iconId, skillType, true);
                skillObj.el.classList.add('casting');
                member.castingMap.set(actionId, skillObj);
            }
            
            handleCastFinish(member, actionId, name, iconId, skillType) {
                // 处理瞬发与读条
                if (!member.visible) return;
                if (member.castingMap.has(actionId)) {
                    const skillObj = member.castingMap.get(actionId);
                    skillObj.isCasting = false;
                    skillObj.el.classList.remove('casting');

                    const iconEl = skillObj.el.querySelector('.skill-icon');
                    if (iconEl) {
                        iconEl.style.zIndex = '15';
                    }

                    member.castingMap.delete(actionId);
                } else {
                    createSkillItem(member, name, iconId, skillType, false);
                }
            }
            
            handleAoeCast(member, actionId, name, iconId, skillType, effectId) {
                //多目标去重
                if (!member.visible) return;
                if (!member.aoeDedupeMap[effectId]) {
                    member.aoeDedupeMap[effectId] = true;
                    this.handleCastFinish(member, actionId, name, iconId, skillType);
                }
            }
            
            handleCastInterrupt(member, actionId) {
                if (!member.visible) return;
                if (member.castingMap.has(actionId)) {
                    const skillObj = member.castingMap.get(actionId);
                    skillObj.isCasting = false;
                    updateCastBarState(skillObj, 'interrupted');
                    member.castingMap.delete(actionId);
                }
            }
        }

        const skillEventHandler = new SkillEventHandler();
        
        // 监听日志行事件
        addOverlayListener('LogLine', (data) => {
            skillEventHandler.handleLogLine(data);
        });

        addOverlayListener('PartyChanged', (e) => {
            if (e.party && e.party.length > 0) {
                const controlsDiv = document.getElementById('party-controls');
                const containerDiv = document.getElementById('party-container');

                if (controlsDiv.style.display === 'none') controlsDiv.style.display = '';
                if (containerDiv.style.display === 'none') containerDiv.style.display = '';

                const partyIds = [];
                
                e.party.forEach(member => {
                    const name = member.name;
                    const id = member.id;
                    const job = member.job;
                    
                    partyIds.push(id);
                    
                    // 更新或创建成员数据
                    const existingMember = partyManager.getMember(id);
                    if (existingMember) {
                        existingMember.updateName(name);
                        existingMember.job = job;
                    } else {
                        partyManager.createMember(id, name, job);
                    }
                    console.log(`Party Member: ID=${id}, Name=${name}, Job=${job}`);
                });

                partyManager.clearNonPartyMembers(partyIds);
                partyManager.updatePartyControls();
                setTimeout(() => {
                    updateSpawnX();
                }, 50);
            }
        });

        // 创建技能 DOM 并加入 activeSkills
        function createSkillItem(member, name, iconId, skillType, hasCastBar) {
            const item = document.createElement('div');
            item.className = 'skill-item';

            if (member.ribbon && member.ribbon.parentElement) {
                const specificWidth = member.ribbon.parentElement.clientWidth;
                if (specificWidth > 0) {
                    currentSpawnX = specificWidth - CELL_SIZE - PADDING_RIGHT;
                }
            }
            item.style.left = `${currentSpawnX}px`;
            
            // 初始位置
            // item.style.left = `${SPAWN_X}px`;

            // 创建图标
            if (skillType === 4) item.classList.add('ogcd');

            const iconEl = document.createElement('div');
            iconEl.className = 'skill-icon';
            if (iconId) {
                const folder = (Math.floor(iconId / 1000) * 1000).toString().padStart(6, '0');
                const iconStr = iconId.toString().padStart(6, '0');
                iconEl.style.backgroundImage = `url('https://cafemaker.wakingsands.com/i/${folder}/${iconStr}.png')`;
            }
            item.appendChild(iconEl);

            // 创建技能名
            const nameLabel = document.createElement('div');
            nameLabel.className = 'skill-name';
            nameLabel.innerText = name;
            adjustFontSize(nameLabel, name);
            item.appendChild(nameLabel);

            // 创建咏唱条
            let castBarEl = null;
            if (hasCastBar) {
                castBarEl = document.createElement('div');
                castBarEl.className = 'cast-bar';
                castBarEl.style.width = '0px';
                item.appendChild(castBarEl);
            }

            member.ribbon.appendChild(item);

            const skillObj = {
                el: item,
                castBar: castBarEl,
                spawnTime: Date.now(),
                isCasting: hasCastBar,
                name: name
            };

            member.activeSkills.push(skillObj);
            return skillObj;
        }

        function adjustFontSize(nameEl, skillName) {
            let fontSize = 10;
            const nameLength = skillName.length;
            if (nameLength > 10) fontSize = 6;
            else if (nameLength > 8) fontSize = 7;
            else if (nameLength > 6) fontSize = 8;
            else if (nameLength > 4) fontSize = 9;
            nameEl.style.fontSize = `${fontSize}px`;
        }

        function animationLoop() {
            const now = Date.now();
            if (currentSpawnX < 50) updateSpawnX();
            
            for (const member of partyManager.members.values()) {
                // 如果成员不可见则不更新
                if (!member.visible) continue;
                
                const activeSkills = member.activeSkills;
                
                // 倒序遍历
                for (let i = activeSkills.length - 1; i >= 0; i--) {
                    const skill = activeSkills[i];
                    const timeAlive = (now - skill.spawnTime) / 1000;
                    
                    // 更新图标位置
                    // const currentLeft = SPAWN_X - (timeAlive * SCROLL_SPEED);
                    const currentLeft = currentSpawnX - (timeAlive * SCROLL_SPEED);
                    skill.el.style.left = `${currentLeft}px`;

                    // 更新咏唱条宽度
                    if (skill.isCasting && skill.castBar) {
                        // let barWidth = SPAWN_X - currentLeft;
                        let barWidth = currentSpawnX - currentLeft;
                        if (barWidth < 0) barWidth = 0; // 保护一下

                        skill.castBar.style.width = `${barWidth}px`;
                    }

                    // 清理不可见元素
                    if (currentLeft < -200 && timeAlive > 1.0) {
                        if (skill.el.parentNode) {
                            skill.el.parentNode.removeChild(skill.el);
                        }
                        for (const [key, value] of member.castingMap.entries()) {
                            if (value === skill) {
                                member.castingMap.delete(key);
                            }
                        }
                        activeSkills.splice(i, 1);
                    }
                }
            }

            requestAnimationFrame(animationLoop);
        }

        // 控件条横向滚动事件处理
        (function setupHorizontalScroll() {
            const controls = document.getElementById('party-controls');
            
            if (controls) {
                controls.addEventListener('wheel', (evt) => {
                    if (controls.scrollWidth > controls.clientWidth) {
                        evt.preventDefault();
                        controls.scrollLeft += evt.deltaY;
                    }
                });
            }
        })();

        function initWelcomeMessage() {
            if (window.__isBrowser) return;
            const controls = document.getElementById('party-controls');        
            controls.innerHTML = '<div class="welcome-message">ActionMon 0.1.1 Ready - 等待数据中...</div>';
            // setTimeout(() => {
            //     if (partyManager.members.size === 0) {
            //         controls.innerHTML = ''; 
            //         controls.style.display = 'none'; 
            //         document.getElementById('party-container').style.display = 'none';
            //     }
            // }, 5000);
        }

        window.addEventListener('error', (event) => {
            console.error('ActionMon Error:', event.error);
        });

        // dev
        const isLocalServer = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
        const isLocalFile = window.location.protocol === 'file:';
        const hasDevParam = new URLSearchParams(window.location.search).has('dev');
        
        if (isLocalServer || isLocalFile || hasDevParam) {
            let frameCount = 0;
            let lastTime = performance.now();
            
            function monitorPerformance() {
                frameCount++;
                const currentTime = performance.now();
                if (currentTime - lastTime >= 1000) {
                    console.log(`FPS: ${Math.round((frameCount * 1000) / (currentTime - lastTime))}, Members: ${partyManager.members.size}`);
                    frameCount = 0;
                    lastTime = currentTime;
                }
                requestAnimationFrame(monitorPerformance);
            }
            monitorPerformance();
        }

        animationLoop();
        startOverlayEvents();
        initWelcomeMessage();
    </script>
</body>
</html>